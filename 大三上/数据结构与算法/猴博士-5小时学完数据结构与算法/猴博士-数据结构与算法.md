# 猴博士-数据结构与算法

## 基础概念

### 逻辑结构与存储结构

逻辑结构描述数据元素之间的**关系**

- 一对一
- 一对多
- 多对多

存储结构描述实际存放数据元素的**物理**结构

一种逻辑结构可以用多种物理结构来实现
物理结构影响逻辑结构上的各种操作的复杂度。

### 算法与复杂度

#### 算法特性

有穷、确定、可行

#### 算法评价标准

正确、可读、健壮、高效

#### (最坏)复杂度

- 时间复杂度：给定输入规模n，在**最坏情况**下需要多少时间一定能做完

- 空间复杂度：给定输入规模n，在**最坏情况**下需要多少额外空间一定能做完

  复杂度是一个**保证**，一个承诺 (即上限；用**O**(数量级)表示)

#### Key

- 逻辑结构描述的是关系，与数据元素本身特点以及计算机参数等没有关系

  - 1.与数据元素本身的形式、内容、大小个数等无关的是数据的(B)
    A.存储结构 B.逻辑结构 C.存储实现 D.运算实现
  - 2.从逻辑上可以把数据结构分成(C)
    A.动态结构和静态结构 B.紧凑结构和非紧凑结构 C.线性结构和非线性结构 D.内部结构和外部结构
  - 3.下面哪个是非线性数据结构(A)
    A.树 B.字符串 C.队列 D.栈

- 算法的5个特性：有穷、确定、可行、输入和输出

- 算法的4个评价准则：正确性、可读性、健壮性、高效性

  - 1.对一个算法的评价，不包括如下(C)方面的内容
    A.正确性和可读性 B.健壮性 C.并行性 D.时间复杂度
    - 分析：给选项形容词前添加“不”字，如果可以接受，说明是评价准则，否则是必须满足的特性。如“不健壮”或“不高效”仍然是能作为一个算法的，只是不够完美。但“不可行”或者“不确定”就无法容忍了，一个算法不可行或无法给出确定结果则不能称之为算法。

- 算法复杂度是一个保证，用O(数量级)表示 (给定输入规模的情况下)(最坏情况/上限)

  - 1.分析下列算法(程序段)的时间复杂度：
    算法输入：n和m

    ```c
    int ans=0;
    for(int i = 0; i < n; i += 1) { // 执行n次
        for(int j = 0; j < m; j += 1) { // 执行m次
    		ans += 1;
        }
    }
    ```

    即n×m次，时间复杂度为O(nm)

  - 2.分析下列算法(程序段)的时间复杂度：
    算法输入：大小为n的数组nums，一个整数val

    ```c
    for(int i = O; i< n; i += 1) { // 执行n次
        if(nums[i]==val) {
            return i;
        }
    }
    ```

    即n次，时间复杂度为O(n)

  - 3.分析下列算法去(程序段)的时间复杂度：
    算法输入：n

    ```c
    int ans=0;
    for (int i = 0; i < n; i += 1) { // 执行n次
        for (int j =1; j < i; j *= 2) { // 执行log2(n)次
            ans+=1;
        }
    }
    ```

    - 分析：外层循环执行n次，因此外层复杂度是O(n)，内层循环与i有关，而i与n直接线性相关，因此内层循环的复杂度是O(log2(n))，内外层是嵌套关系，需要将复杂度相乘，得到总的复杂度为O(nlgn)。

  - 4.分析下列算法(程序段)的时间复杂度：
    算法输入：n

    ```c
    int ans=0;
    for(int i = 1; i <= n; i += 1) { // 执行n次
        if (i > 1000) break; // 但至多执行1000次
    	ans += i;
    }
    ```

    - 分析：无论输入n是多少，循环至多执行1000次，因此时间复杂度为O(1000)，也即常数复杂度，不管这个常数多大，我们都认为其为O(1)。

  - 5.在算法输入规模为n时，算法运行时间正比于9log(3n)，则该算法的时间复杂度为(O(n))

    - 分析：9log(3n=9nlog(3)，对于算法的复杂度分析时，我们不关系常数，只关心和输入规模n有关的数量级，因此0(9nlog(3))=== O(n)

## 线性表

### 线性表的顺序存储和链式存储

线性表(逻辑结构)；顺序存储/链式存储 (存储结构(物理结构))

线性表：一对一

- 顺序存储：按顺序放在一起，相邻元素通过内存地址相邻产生联系"**随机存取**"
- 链式存储：元素随机放置在内存中任意位置，每个元素除了存放数据，也保存了其相邻元素的
  内存地址来实现线性关系"**顺序存取**"

#### Key

1. 线性表是指各数据元素间保持“1对1”关系的数据结构
   1. 设顺序表中第一个元素的内存地址为100，单个数据元素长度为2，则第5个元素的地址为(B)
      A.110 B.108 C.105 D.112
   2. 链式存储的线性表中，每个数据元素所占的存储空间(A)
      A.分为两部分：结点值和维护节点间关系的指针 B.只有一部分：结点值
      C.只有一部分：维护结点间关系的指针 D.分为两部分：结点值和结点空间大小
   3. 设顺序表中有n个数组元素，则读取第i个数组元素的平均时间复杂度为(D)
      A.O(nlgn) B.O(n) C.O(n/2) D.O(1)
   4. 单链表的储存密度(<)1 (<,>或=)
2. 线性表分为顺序表(数组)和链表，分别通过**元素相邻**和保存**指针域**的方式来实现“1对1"



### 线性表基本操作(顺序表、(单)链表)

#### 顺序表

顺序表查找(定位)元素：按**值**查找

- 给定长度为n的线性表，查找值为v的元素
- (最坏)从头到尾遍历=>时间复杂度O(n)

顺序表新增/删除元素

- 给定长度为n的顺序表，在指定位置i插入一个新元素
- 给定长度为n的顺序表，删除位置i的元素
- 需要将位置i到位置n-1的所有元素都向后或向前挪一格
- 在**最坏情况**(i=0)下，需要挪动全部的n个元素=>时间复杂度为**O(n)**
- 无需利用额外空间=>空间复杂度为O(1)

顺序表更新元素

- 给定长度为n的顺序表，更新位置i的元素
- 无论i的值如何，都可以通过i直接访问位置i元素，将其更新为v’=>时间复杂度
  为0(1)=>**随机存取**

#### (单)链表

(单)链表新增元素

- 给定长度为n的顺序表，在第i个结点插入一个新元素
- **寻找前驱节点：**首先需要从头结点开始逐个向后找**i-1**次=>时间复杂度为O(n)
- 找到后插入只需要修改第i-1个结点和待插入结点的[后继结点地址]即可=>O(1)
- 无需利用额外空间=>空间复杂度为O(1)
- **TIPS：一定注意要先把新节点指向后继后，再把前趋指向新节点**

(单)链表删除元素

- 给定长度为n的单链表，删除第i个结点
- 需要移动到第i个结点的前驱结点，最坏情况下移动n-1次=>时间复杂度为O(n)
- 修改前驱结点的后继指针=>O(1)
- 无需利用额外空间=>空间复杂度为O(1)

(单)链表更新元素

- 给定长度为 n 的顺序表，更新第i个结点的值
- 需要从头结点开始按顺序找到第1个结点才能访问并更新它=>顺序存取
- 最坏情况遍历整个链表=>时间复杂度为0(n)

#### Key

1. 顺序表中增加和删除一个元素将导致该位置后的元素前移或后移，复杂度为O(n)
   1. 设顺序表中有n个元素，往其插入或从其删除一个元素，平均要移动的元素个数为(2/n)
   2. 往一个长度为127的顺序表中插入一个元素，平均要移动的元素个数为(B)
      A.8 B.63.5 C.63 D.7
   3. 设顺序表中有n个元素，则时间复杂度为O(1)的操作是(A)
      A.访问第i个结点(i∈[1,n]) B.删除第i个结点(i∈[1,n])
      C.在第i个结点后插入一个新元素(i∈[1,n]) D.将顺序表从小到大排序
2. 单链表增加和删除元素虽然不用移动元素，但需先找到其前驱结点，复杂度为O(n)
   1. 下列说法正确的是(C)
      A.如果插入操作频繁发生在表头部，顺序表和单链表效率接近
      B.如果删除操作频繁发生在表头部，顺序表比单链表效率更高
      C.如果插入操作频繁发生在表尾部，顺序表比单链表效率更高
      D.如果删除操作频繁发生在表尾部，顺序表和单链表效率接近
3. 若线性表需要频繁更新元素->选择用顺序表实现(数组)
4. 若线性表需要频繁插入删除元素->选择用链式表实现
   1. 下列说法错误的是(~~B~~)D
      A.对于顺序表和链表来说，定位元素的效率接近
      B.顺序存储的线性表可以随机存取
      C.顺序表需要物理上连续的内存空间，因此存储管理不够灵活
      D.线性表的顺序存储实现优于链式存储结构

### 线性表合并操作

#### 线性表的集合式合并：只合并不同元素

- 设A表长度为**n**，B表长度为**m**
- 对于B表中的每个元素，都需要先判断其是否已经存在A里=>O(mn)
- 如果存在，无需插入，如果不存在，将其插入在A的末尾=>O(1)
- 总时间复杂度为O(mn)
- 空间复杂度
  - 顺序表：O(m+n)
  - 链表：O(1)

#### 合并两个有序表：本来分别有序，合并结果仍然有序

- 设A表长度为n，B表长度为**m**
- 先预留结果表空间：n+m个元素
- 从表头开始同时逐个访问A表和B表元素，将当前位置上较小者放入结果表并后移一位
- 总时间复杂度为O(m+n)
- 空间复杂度为O(**m+n**)

#### 合并两个有序单链表

- 设A表长度为**n**，B表长度为**m**
- 先创建一个头结点(哑结点dummy)，其数据没有实际意义，只为用它的**[指针域]**
- 从表头开始逐个同时遍历A和B，将**当前已完成合并的表尾元素**的后继节点设置为当前A和B游
  标中较小的一个，并将该游标向后移动一位
- 时间复杂度为O(m+n)
- 空间复杂度为O(**1**)

#### Key

1. 合并两个有序表：逐一比较两表当前元素，将正确的元素添加进结果表并移动游标
   1. 合并两个长度为n的有序表，可能的最小比较次数为(C)
      A.2n B.2n-1 C.n D.1

### 代码实现

[线性表-顺序表](https://github.com/mole9630/UNotes/tree/main/大三上/数据结构与算法/校内课程-实验课笔记/241011) | [线性表-链表](https://github.com/mole9630/UNotes/tree/main/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B-%E5%AE%9E%E9%AA%8C%E8%AF%BE%E7%AC%94%E8%AE%B0/241018)



### 栈与队列

### 栈和队列的特征

栈：**后**进先出(LIFO)

- 栈：受限制的线性表，只允许从表的一端操作，这端称为**栈顶**，另一端为**栈底**
- 压入元素(**push**)：往栈顶新增一个元素，新元素成为新栈顶
- 弹出元素(**pop**)：移除栈顶元素，原栈顶下的元素成为新栈顶/或栈变为空栈

队列：**先**进先出(FIFO)

- 队列：受限制的线性表，只允许从表的两端操作，一端为**队首**，一端为**队尾**
- 入队(**enqueue**)：往队尾新增一个元素，新元素成为新队尾
- 出队(**dequeue**)：移出队首元素，下一个元素成为新队首/或队列变为空

#### Key

1. 栈是一种**先进后出**的数据结构，Pop和Push操作仅在栈顶进行
   1. 设入栈序列为1234，则出栈序列不可能是(C)
      A.1234 B.1324 C.4312 D.3214
   2. 设入栈序列为ABC，则可能的出栈序列种类有(~~C~~ D)种
      A.1 B.3 C.4 D.5
      - 分析：考虑A在出栈序列中的位置，有3种可能性，若A第一个出栈，该情况的总数量为B和C出栈序列的种类数，共”BC”和”CB“两种；若A第二个出栈，那B必然在它前面，C必然在它后面，只有一种情况；若A第三个出栈，则该情况总数也为B和C出栈序列的种类数。因此答案2+1+2=5
   3. 设入栈序列为1,2,3...n，出栈序列为p~1~，p~2~，p~3~...p~n~，若p~1~=n，则p~i~为(C)
      A.i B.n-i C.n-i+1 D.不确定
      - 分析：p~1~=n说明第一次pop发生在n入栈后，也即所有元素入栈后，此后栈内剩下的元素只能按照插入顺序的逆序依次出栈。
        根据栈LIFO的特性，出栈序列中的每一个p~i~都满足i+p~i~=1+n，因此p~i~=n-i+1

### 栈和递归

- 栈后进先出的特点天然地和程序中函数调用的关系相吻合
- 程序执行时，在函数A中执行到调用另一个函数B的语句时，会立刻进入被调函数B执行其代码，完成后返回到A的下一行继续执行A的剩余代码
- 因此在操作系统执行代码时，函数间的调用-返回关系正是通过**调用栈**来维护
- **★**函数的递归调用本质也是一个栈型调用，因此可以利用栈将一个递归函数改写为
  完全等价的非递归函数，避免了操作系统层面的调用栈开销

### 栈和队列的应用

#### 栈的应用：括号匹配

- 目的：判断一个字符串中括号是否匹配
- [{(O)}->匹配，[{(D)}->不匹配
- 当遇到一个左括号时，我希望能立刻遇到它的另一半，但如果紧接着又遇到了一个左括号
  那它的需求比我更紧迫，我需要**先**处理**后**来的这个左括号
- 后来的需要先满足->后进先出问题->用栈解决

#### 栈的其他应用

- 表达式求值，如求1+2*3
- 进制转换
- 非递归的深度优先遍历(DFS)

#### 队列的应用：循环队列

- “**假溢出**”现象：底层顺序表前部的可用空间无法再利用上了

### 代码实现

[顺序栈](https://github.com/mole9630/UNotes/tree/main/大三上/数据结构与算法/校内课程-实验课笔记/241025)|[循环队列](https://github.com/mole9630/UNotes/tree/main/大三上/数据结构与算法/校内课程-实验课笔记/241101)

#### 循环队列实现

循环队列的底层是一个数组，通过维护队头和队尾在此数组中的下标来实现

#### Key

1. 顺序栈的底层是一个数组空间，并通过维护当前栈大小实现栈

2. 顺序栈的当前栈顶元素下标和栈大小是top=size-1的关系

   1. 设Stack是顺序栈的一种实现，(a)处应填入的代码为(stk.size--)
      ```c
      struct Stack {
          Elem data[MAX_SIZE];
          int size = 0;
      }
      void Pop(Stack &s) {
      if (stk.size == 0) return false;
          (a);
          return true;
      }
      ```

3. 循环队列的容量是 MAX_SIZE-1

4. 循环队列当前元素数量计算

   1. 假设一循环队列的底层数组为array[M]，我们约定f表示为当前队首元素，b为当前队尾元素
      的后一个元素，则当前队列内元素个数为(B)
      A.b-f B.(b-f+M)%M
      C.b-f+M D.(f-b+M)%M

5. 首尾相接：循环队列判满条件为`(back+1)%MAX_SIZE==front`

6. 首尾重合：循环队列判空条件为`back==front`

   1. (a)处应填入的代码为(`queue.front==queue.back`)
      ```c
      bool Dequeue_CQ(CQueue &queue) {
          if((a))
          return false；//头尾重合表示队列为空
          queue.front = (queue.front + 1) % queue.capacity; //queue.capacity(即M)
          return true;
      }
      ```




## 树与二叉树

**理解**以下名词：

- 树、森林、二叉树
- 根、孩子、子树、叶子节点
- 树的高度与结点的度
- 满二叉树与完全二叉树
- 顺序二叉树、链式二叉树
- 先序/中序/后序遍历
- 哈夫曼树与哈夫曼编码

**熟悉**以下过程及其复杂度：

- 树的4种遍历过程
- 森林/树转换为二叉树
- 构建哈夫曼树

**理解**以下关键代码：

- 二叉树先序/中序/后序遍历的递归实现
- 利用队列实现二叉树的BFS
- 求树高度的递归实现

**熟练**以下题型：

- 二叉树结构的各种数值计算
- 给定森林/树，转化为二叉树
- 给定中序+先序/后序序列，还原二叉树结构
- 给定二叉树，写出其各种遍历的结果序列
- 给定字符频率表求哈夫曼编码

### 树和森林

- 树：一对多的结构(可1对0，1对1，1对多)，有一个起点"根结点"
- 结点：树的一个数据元素
- 孩子：1对多里的"多"
- 子树：以某个孩子结点为根的一棵树
- 叶子结点：没有孩子的结点
- 森林：多棵树

### 二叉树结果

#### 二叉树

- 二叉树：每个结点**至多**有两个孩子(可以1个或0个)(度至多为2)，分别称为**左孩子**和**右孩子**
- 左孩子(若有)是左子树的根，右孩子(若有)是右子树的根
- 高度(深度)：**最深**的叶子结点所在层数

#### 二叉树的重要性质

- 第i层至多有2i-1个结点

- 高度为h的树至多有2h-1个结点

  | 层号(高度) | 叶子节点上限 | 结点总目上限 |
  | :--------: | :----------: | :----------: |
  |     1      |      1       |   2^1^-1=1   |
  |     2      |      2       |   2^2^-1=3   |
  |     3      |      4       |   2^3^-1=7   |
  |     4      |      8       |  2^4^-1=15   |
  |    ...     |     ...      |     ...      |
  |     i      |    2^i-1^    |    2^i^-1    |

#### Key

1. 二叉树每个结点有0或1或2个孩子，叶子结点没有孩子
2. 二叉树的高度指从根节点向下直至最深叶子结点的高度
   - 由3个结点可以构成多少棵结构不同的二叉树？(D)
     A.2 B.3 C.4 D.5
   - 一棵二叉树有1025个结点，则其高度为(~~D~~)C
     A.10 B.11 C.11至1025之间 D.10至1025之间

#### 两种特殊的二叉树

- 满二叉树(FULL)
  - 装满的二叉树，高为h=>有2h-1个结点
- 完全二叉树(Complete)
  - 只在最下一层的最右边有空缺

#### Key

1. 满二叉树是满的，完全二叉树只是完整了，但不一定满

   - 一棵完全二叉树有1001个结点，则其叶子结点个数为()
     A.250 B.254 C.500 D.501

     - 分析：

       此类题目首先找该完全二叉树T1的上层满二叉树T2。
       因2^9^-1<1001<2^10^-1，所以T2是一棵高度为9的满二叉树，其叶子结点数量为2^8^=256，总结点数为2^9^-1=511
       则T1最后一层左端有1001-511=490个叶子结点
       这些结点能作为T2叶子结点中490/2=245个结点的孩子，使其变为非叶结点
       则T2仍剩256-245=11个叶子结点，答案为11+490=501

#### 树/森林转换为二叉树

- 树转为二叉树
  - 每个结点只保留第一个孩子(老大)作为左孩子，剩下的孩子(老大的兄弟们)依次接到老大的右孩子链上
- 森林转为二叉树
  - 各树分别转为二叉树
  - 各树根用右孩子链相连

#### Key

1. 森林向二叉树转化是确定且唯一的过程
   - 将一棵树转换为二叉树后，其形态(A)
     A.是唯一的 B.有多种 C.有多种，但根结点都没有右孩子 D.有多种，但根结点都没有左孩子
     - 分析：是唯一的，且根结点没有右孩子

#### 二叉树顺序存储实现

- 顺序二叉树(底层是数组）
- 顺序树中结点i的左右孩子分别是2i+1和2i+2(i从0开始计数)
- 若结点为空，使用特殊值(如0)表示

#### 二叉树链式实现

链式树(二叉链表)

```c
typedef struct TreeNode {
    int data;
    struct TreeNodee *left;
    struct TreeNode *right;
} TreeNode;
```

### 二叉树的遍历

- 遍历：按某种确定的次序逐个访问所有结点 (时间复杂度是O(n))
- 先序遍历：**当前结点**-左子树-右子树
- 中序遍历：左子树-**当前结点**-右子树
- 后序遍历：左子树-右子树-**当前结点**
- 层序遍历：逐层从左向右遍历各个结点

#### 二叉树先序/中序/后序遍历

- 注意：右孩子是右子树的根，左孩子是左子树的根
- 注意：一棵树是用其根结点表示的，因从根结点出发我们足以访问整棵树
- 先序遍历：**根**左右
- 中序遍历：左**根**右
- 后序遍历：左右**根**

#### Key

1. 二叉树三种遍历顺序中，左子树都先于右子树，区别在于访问根的次序

2. 可以通过中序+先序/后序序列之一来还原二叉树结构，先+后则不行

   - ★一颗二叉树的先序遍历序列为3541982，中序遍历序列为5413892，请还原其结构

     - 分析：

       中+先/后还原树结构的问题，关键点在于可以通过先/后序序列**确定根结点**，再通过中序遍历里
       根结点的位置**划分左右子树**，问题减小为分别还原左右子树，依次逐层往下直至还原完成。

### 哈夫曼树

#### 哈夫曼树和哈夫曼编码

- 初始时，一堆独立结点，结点有自己的权值
- 重复地让当前**权值最小**的两个**根结点**作为左右孩子，**生成**新的根结点，新结点权值为它们的**权值之和**，直至形成一颗二叉树

#### 哈夫曼树的特点

- 越靠近根节点，权值越大
- 初始结点全是后来的叶子结点
- 叶子结点权值越大，离根结点越近=>路径越短
- 每一个叶子结点有一个唯一编码(不定长)
- 最大程度节省空间！越常用的字符码长越短。
- **题型**：给一个字符-频率表，构造哈夫曼树来求哈夫曼编码表

### 代码实现

[图1](https://github.com/mole9630/UNotes/tree/main/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B-%E5%AE%9E%E9%AA%8C%E8%AF%BE%E7%AC%94%E8%AE%B0/241122) | [图2](https://github.com/mole9630/UNotes/tree/main/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B-%E5%AE%9E%E9%AA%8C%E8%AF%BE%E7%AC%94%E8%AE%B0/241129)



## 图

**理解**以下名词：

- 有向图/无向图，加权图
- 度 (入度/出度)
- 连通与连通分量
- 稀疏和稠密
- 邻接矩阵和邻接表
- DFS和BFS
- 贪心思想
- 最小生成树与Prim算法
- 迪杰斯特拉算法
- 有向无环图与拓扑排序
- AOE网络
- 关键活动与关键路径

**熟悉**以下过程及其复杂度：

- 图的DFS和BFS
- Prim算法过程
- 迪杰斯特拉算法过程
- *拓扑排序过程

**理解**以下关键代码：

- *利用递归实现DFS
- *利用队列实现BFS

**熟练**以下题型：

- 和图的数值特征有关的计算
- 图的两种表示方式以及比较
- **给定图/邻接矩阵/邻接表，DFS与BFS全过程模拟**
- **给定图/邻接矩阵/邻接表，模拟最小生成树的生成过程(Prim算法)**
- **给定图/邻接矩阵/邻接表，模拟迪杰斯特拉算法过程**
- ***AOE网络求解关键路径**

### 图的基本概念(多对多的逻辑结构)

- 假设ABCDEFG是7个电话，之间的连线表示修有通信线路(A-B-C-D-E F-G)
- 电话就是图的**顶点**v~i~∈V，通信线路是**边**e~i~∈E，G={V,E}就是一个图 (V=Vertice；E=Edge)
- 只要两个电话间有线路，就可以相互通话=>**无向图**
- 电话(顶点)连接的线路(边)数量：**度**
- ABCDE和GF之间消息无法传递：**不连通**
- ABCDE和GF是两个**连通分量**
- 若边上有数值，则是**加权图**
- 若带箭头连线的图，则是**有向图**
- **入度**：其他订单箭头指向该顶点的数量
- **出度**：该顶点指向其他顶点的数量

#### Key

1. 在一个无向图中，所有顶点的度数之和为边数量的2倍
2. 在一个有向图中，所有顶点的出度之和==所有顶点的入度之和
   - 无向图G={V，E}中，|V|=n，则|E|最大为(D)
     A.n B.n^2^ C.n(n-1) D.n(n-1)/2
     - 分析：n个结点，每个结点都与除自己外其他结点间有一条边相连，而一条边连接了两个结点，因此答案为n(n-1)/2
   - 从某一城市出发，可以沿着高速公路经或不经中转抵达所有其他城市，则这几个城市是(D)
     - A.有向的 B.强连通的(仅适用于有向图) C.加权的 D.连通的

### 邻接矩阵和邻接链表

#### 邻接矩阵

- 设|V|=n，图可用一个n*n方阵表示
- 即一个二维数组`AdjMat[n][n]`
- `AdjMat[i][j]`表示v~i~和v~j~的邻接情况

![](./imgs/6/6.1.png)

- 设IVl = n，图可用一个n*n方阵表示
- 即一个二维数组`AdjMat[n][n]`
- `AdjMat[i][j]`表示v~i~到v~j~的邻接情况

![](./imgs/6/6.2.png)

#### 邻接表

- 每个顶点用一个链表存下自己的邻居
- |V|=n，有n个链表，即图可用一个链表的数组`AdjList[n]`存储
- `AdjList[i]`表示顶点v~i~的链表(头)
- 从`AdjList[i]`开始可以遍历所有以v~i~的邻居

![](./imgs/6/6.3.png)

#### 邻接矩阵和邻接表的比较

- 设G = {V, E}, IMI = n.
- 邻接矩阵无论如何都需要一个二维数组`[n][n]`，而邻接表中每条链表长度取决于它有多少邻居
- 邻接矩阵访问`AdjMat[i][j]`是O(1)的，但邻接表访问特定边需要顺着起点的链表向后查找
- 邻接表的优点：
  - 在边较少时节省许多空间=>适用于稀疏图 (邻居少=>即边较少)
- 邻接表的缺点：
  - 无法直接获得某条边信息，需要v~i~链表进行从头顺序存取，最坏情况下O(n)

### 图的DFS和BFS遍历

#### DFS:深度优先遍历(Depth First Search)

- 遇到新的邻居就进去...直到没有可以进的邻居了再返回
- 优先进入后来遇到的邻居=>递归/栈

![](./imgs/6/6.4.png)

以B为起点进行DFS：

- 访问B
  - 访问B的下一个未访问邻居D
    - 访问D的下一个未访问邻居C
      - C所有邻居都被访问过了，返回
    - 访问D的下一个未访问邻居A
      - A所有邻居都被访问过了，返回
    - 访问D的下一个未访问邻居E
      - E所有邻居都被访问过了，返回
    - D所有邻居都被访问过了，返回
  - B所有邻居都被访问过了，**当前连通图**遍历完毕

#### BFS:广度优先遍历(Breath First Search)

- 先把当前结点的邻居都遍历完，再按先来后到遍历邻居的邻居们，**逐层向外**扩张 (层序遍历)
- 优先进入先访问的邻居的邻居=>队列

![](./imgs/6/6.4.png)

| 以B为起点进行DFS                          | 队列        |
| ----------------------------------------- | ----------- |
| 将起点B入队                               | ←[B]←       |
| 访问当前队首B，它出队，未访问邻居D, E入队 | ←[D, E]     |
| 访问当前队首D，它出队，未访问邻居A, C入队 | ←[E, A, C]← |
| 访问当前队首E，它出队，它没有未访问邻居了 | ←[A, C]←    |
| 访问当前队首A，它出队，它没有未访问邻居了 | ←[C]←       |
| 访问当前队首C，它出队，它没有未访问邻居了 | ←[]←        |

#### Key

1. DFS每步操作：进入当前结点下一个未访问的邻居，如无则返回
2. BFS每步操作：进入当前队首结点并让其出队，将其未访问邻居入队

### 最小生成树
### 迪杰斯特拉算法
### 拓扑排序
### AOE网络与关键路径求解
